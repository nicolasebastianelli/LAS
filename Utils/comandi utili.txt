#COMANDI UTILI ANALISI SISTEMA
$ du(dimensione cartella ricorsivamente)
$ df (utilizzo disco) 
$ ps auxw o $ ps auxfw(lista processi)
$ ps h -o user -C process.sh (lista degli utenti che utilizzano tale processo)
$ free(info su ram)
$ uptime(info su sistema)
$ last(ultimi login)
$ top(processi aperti)
$ lsof(tutti i file aperti)
$ vmstat 1(simile a top)
$ fuser * (lista file aperti e pid in una cartella)
$ atq(lista dei task in attesa)
$ atrm (rimuove task in attesa)
$ echo "bin/date > /tmp/prova.at 2>/dev/null" | at now +1 minutes (esecuzione comando con redirizione output su file)
#MODIFICA FILE DI LOG: $ nano /etc/rsyslog (file di log)(scrivere all interno ciò che si vuole modificare, es:reindirizzare output, local4.* 192.168.56.203)
$ systemctl restart rsyslog
$ systemctl status rsyslog
$ logger -p local4.info "Prova"
$ kill -HUP $(cat /var/run/rsyslogd.pid) (chiude i file aperti e li riapre da un processo) 
$ echo "bin/date > /tmp/prova.at 2>/dev/null" | at now +1 minutes
$ trap -l (lista di tutti i segnali)
$ trap "comando" 14 (quando scatta il segnale esegue il comando)
$ trap -p (lista tutte le regole di trap create)
$ find . -type f -name “*.txt” (trova tutti i file .txt a partire dalla cartella corrente) 
$ find / -type d -name prova (trova tutte le cartelle del filesystem con nome prova)
$ find / -size +50M -size -100M (trova tutti i file con dimensione compresa tra 50 mb e 100 mb)
$ netstat (mostra informazioni di rete)
$ netstat -nt (mostra le connessioni attive TCP a causa di -t )
$ netstat -npt (mostra le connessioni attive mostrando anche il processo che lo ha lanciato)
$ ss -npt (molto simile a netstat)
$ awk (simile a cut)
$ nohup "comando" (esegue un comando che prosegue anche in caso di chiusura del terminale)
$ at (esegue un comando in un determinato lasso di tempo una sola volta)
#es:  $ "command" | at now + 5 minutes 2>&1 | grep ^job | awk '{ print $2 }' (pianifico l'esecuzione di command e ottengo a quale job appartiene
$ atrm $JOB (annulla l'esecuzione del comando at di un determinato job)
$ cron (esegue un comando in un determinato lasso di tempo ciclicamente)
$ sed -e 's/pid=/\n/g' (sostituisce la stringa "pid=" con la stringa "\n" globalmente ) questo metodo è utilizzato per facilitare la ricerca tramite grep poichè genera delle nuove righe
$ xargs "command" (esegue il comando 1 volta per ogni parametro passato come argomento , consigliato utilizzarlo in pipeline) #es: $ xargs "command" $1 $2 ("eseguirà command $1" e "command $2")
$ stat "$NOME_FILE" | egrep "Size:" | awk '{ print $2 }' (recupero dimensione file)
$ scp host:foobar.txt /some/local/directory (copia da un host in una dir)
$ scp foobar.txt host (copia file locale verso un host)
$ function elenca_connessioni() {netstat -nt | egrep "[[:space:]]$IPROUTER:22[[:space:]]" | awk '{ print $5 }' | cut -f1 -d:} ; for IP in $(elenca_connessioni) ; do done (elenco id connessi in ssh)
$ wc -c (conta numero caratteri)
$ wc -l (conta numero linee)
$ ls -t | head -1 (ottiene il file più recente)
$ ls -t | tail -1 (ottiene il file meno recente)
$ ps U “$(whoami)” | grep -v "^$$" | awk '{ print $1 }' | xargs kill (chiude tutti i processi gentilmente)
$ ps U “$(whoami)" | grep -v "^$$" | awk '{ print $1 }' | xargs kill -9 (chiude tutti i processi forzatamente)
$ date +%s (numero di secondi dall’inizio di unix)
$ tar -C $HOME -czpf - * | cat > /users/file.tgz (crea tar da stdin)
$ cat /file.tgz | tar -C $HOME -x -z -f -  (estrae tar su stdin)
$ TRAFFICO=$(iptables -Z -vnxL “CHAIN” | tail -1 | awk '{ print $2 }’) (byte generati su una chain) 
$ TRAFFICO=$[ `iptables -Z -vnxL “CHAIN” | tail -1 | awk '{ print $2 }'` / 1024 ] (kilobyte generati su una chain)
$ logger -p local0.info [message] (logga in local0.info)
$ ifconfig eth2 | grep "inet addr" | awk -F 'addr:' '{ print $2 }' | cut -f1 -d" " (ottiene ip locale)
$ for S in `seq 11 15` do ssh 10.1.1.$S ; done (per iterare su una serie di host)